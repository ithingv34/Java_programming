# 클래스


## 객체 지향 프로그래밍의 의미 (Object Oriented Programming)

현실 세계에서 어떤 제품을 만들 때는 부품을 먼저 만들고 이 부품들을 하나씩 조립해서 완성품을 만든다. 이처럼 소프트웨어 개발에 있어서도 해당하는 객체를 먼저 만들고, 이 객체들을 하나씩 조립해서 완성된 프로그램을 만드는 기법을 **객체 지향 프로그래밍**이라 한다.

**객체는 무엇일까?**

객체란 물리적으로 존재하거나 개념적인 것 중에서 다른 것과 **식별** 가능한 것을 말한다.
예를들어 자동차, 자전거, 책, 사람, 학과, 강의, 주문등도 모두 객체가 될 수 있다.

객체는 `속성`과 `동작`으로 구성된다. 사람은 이름, 나이 등의 `속성`이 있고 걷다, 먹다, 자다와 같은 `동작`을 가진다. 자바에서는 이러한 속성과 동작을 **필드**와 **메소드**라고 부른다.

**객체 모델링**

현실 세계의 객체를 소프트웨어 객체로 설계하는 것을 객체 모델링이라 한다. 객체 모델링은 현실 세계의 객체의 대표 속성과 동작을 추려내어 소프트웨어 객체의 필드와 메소드로 정의하는 과정이라 할 수 있다.

---

## 클래스의 구성요소

**메소드**

---
**가변길이 매개변수**
메소드를 호출할 때는 매개변수의 개수에 맞게 매개값을 제공해야한다. 만약 메소드가 가변길이 매개변수를 가지고 있다면 매개변수의 개수와 상관없이 매개값을 줄 수 있다. 

```java
int sum(int ... values)

// 호출
int result = sum(1,2,3);
int result = sum(1,2,3,4,5);
```

매개값들은 자동으로 배열 항목으로 메소드에서 사용되며 메소드 호출 시 직접 배열을 매개값으로 제공해도 된다.

```java
int[] values = {1,2,3};
int result = sum(values);

int result = sum(new int[] {1,2,3});
```

---

**인스턴스 멤버와 정적 멤버**

필드와 메소드는 선언 방법에 따라 **인스턴스 멤버**와 **정적 멤버**로 분류할 수 있다. 인스턴스 멤버로 선언되면 객체 생성 후 사용할 수 있고, 정적 멤버로 선언되면 객체 생성 없이도 사용할 수 있다.

---

**인스턴스 멤버**

```java
public class Account {
    // 인스턴스 필드 선언
    int money;
    // 인스턴스 메소드 선언
    void addMoney(int money) { ... }
}
```

:::warning
인스턴스 필드의 경우 객체마다 따로 존재하지만 인스턴스 메소드는 각 객체마다 존재하지 않고 메소드 영역에 저장되고 공유된다. 메소드를 객체마다 저장한다면 중복 저장으로 인하여 메모리 효율이 떨어진다. 다만 객체 없이는 사용하지 못하도록 제한된다.
:::


---
**this 키워드**

객체 내부에서는 인스턴스 맴버에 접근하기 위해 `this`를 사용할 수 있다. 객체는 자기 자신을 `this`라 지칭한다. 

```java
public class Account {

    int money;

    // 생성자
    Account(int money) {
        this.money = money; // 매개변수를 필드에 대입 (this 생략 불가) 
    }

    // 메소드
    void addMoney(int money) {
        this.money += money;
    }    
}
```

---
**정적 멤버**

자바는 **클래스 로더**를 이용하여 클래스를 메소드 영역에 저장하고 사용한다. 정적 멤버란 메소드 영역의 클래스에 고정적으로 위치하는 멤버를 말한다. 그렇기 때문에 정적 멤버는 객체를 생성할 필요 없이 클래스를 통해 바로 사용할 수 있다.


- 정적 멤버 선언
  - 필드와 메소드는 모두 정적 멤버가 될 수 있다. 정적 필드와 정적 메소드로 선언하기 위해서 `static` 키워드를 추가한다.
  ```java
    public class 클래스 {
        // 정적 필드 선언
        static 타입 필드 [= 초기값];

        // 정적 메소드
        static 리턴타입 메소드(매개변수, ...) {...}
    }
  ```

:::tip

정적 필드

- 객체마다 가지고 있을 필요가 없는 공용적인 필드는 정적 필드로 선언하는 것이 좋다. 예를들어 계산기 클래스에서 원의 넓이나 둘레를 구할 때 사용하는 파이(Π)는 객체마다 가지고 있을 필요가 없기 때문에 정적 필드로 선언하는 것이 좋다. 

정적 메소드

- 인스턴스 필드를 이용하지 않는 메소드는 정적 메소드로 선언하는 것이 좋다. 단순히 외부에서 주어진 매개값만 가지고 처리하는 경우에 사용하면 좋다.
:::

---

**정적 멤버 사용**

클래스가 메모리에 로딩되면 정적 멤버를 바로 사용할 수 있다. 

```java
public class Calculator {
    static double pi = 3.14159;
    static int plus(int x, int y) { return x + y};
    static int minus(int x, int y) { return x - y};
}

// 클래스이름으로 바로 접근하기
Calculator.pi // 3.14159;
Calculator.plus(2,1); // 3
Calculator.minus(2,1); // 1
```
---
**정적 블록**

만약 복잡한 초기화 작업이 필요한 경우라면 `정적 블록`을 이용할 수 있다. 정적 블록은 클래스가 메모리로 로딩될 때 자동으로 실행된다. 정적 블록이 클래스 내부에 여러개 가 선언되어 있을 경우에는 선언된 순서대로 실행된다.

```java
public class Tv {
  static int money = 100;
  static {
    money += 100;
  }
}

class Main {
  public static void main(String[] args) {
  System.out.println(Tv.money); // 200
  }
}
```

:::warning
정적 메소드와 정적 블록은 객체가 없어도 실행된다는 특징때문에 내부에 인스턴스 필드나 인스턴스 메소드를 사용할 수 없다. 또한 객체 자신의 참조인 this도 사용할 수 없다. 만약 정적 메소드와 정적 블록에서 인스턴스 멤버를 사용하고 싶다면 객체를 먼저 생성하고 참조 변수로 접근해야 한다.
:::

## 캡슐화

캡슐화란 객체의 데이터(필드), 동작(메소드)를 하나로 묶고 실제로 구현된 내용을 외부로부터 숨기는 것을 말한다. 외부 객체는 내부의 구조를 알지 못하며 객체가 노출하는 필드와 메소드만 이용할 수 있다.

---

**접근 제한자**

객체의 무결성을 유지하기 위해 접근 제한자를 사용하여 객체의 필드를 외부에서 변경하거나 메소드를 호출할 수 없도록 하여 중요한 정보를 보호할 수 있다.  

접근 제한자는 `public`, `protected`, `private`의 세 가지 종류가 있으며 `default`는 접근 제한자가 앞에 붙지 않은 상태를 말한다.

|접근 제한자| 대상|제한범위|
|:-|:-|:-|
|public|클래스, 필드, 생성자, 메소드 | 없음|
|protected| 필드, 생성자, 메소드 | 같은 패키지거나, 자식 객체만 사용 가능|
|default| 클래스, 필드, 생성자, 메소드| 같은 패키지|
|private| 필드, 생성자, 메소드 | 객체 내부|
- 밑으로 갈 수록 접근 제한이 강화된다.

---
**Getter와 Setter**

객체의 필드를 외부에서 마음대로 읽고 변경할 경우 객체의 무결성이 깨질 수 있다 이러한 문제를 막기 위해 외부에서의 필드 접근을 막고 `Getter/Setter` 메소드를 통해 필드에 접근하는 것을 허용하는 방법이 선호된다.

```java
public class Car {
    // 필드 선언
    private int speed;

    // Getter
    public int getSpeed() {
        return speed;
    }

    // Setter
    public void setSpeed(int speed) {
        if (speed < 0) {
            this.speed = 0;
            return;
        } else {
            this.speed = speed;
        }
    }   
}
```

**싱글톤 패턴**

애플리케이션 전체에서 단 한 개의 객체만 생성해서 사용하고 싶다면 `싱글톤` 패턴을 적용할 수 있다. 싱글턴 패턴의 핵심은 **생성자를 private으로 제한하여 외부에서 new 연산자로 생성자를 호출할 수 없도록 막는 것**이다.

```java
private 클래스() {}
```

생성자를 호출할 수 없으므로 외부에서 마음대로 객체를 생성할 수 없다. 그 대신 싱글톤 패턴이 제공하는 정적 메소드를 통해 간접적으로 객체를 얻을 수 있다.

```java
public class Singleton {
    // private 접근 권한을 가지는 정적 필드 선언과 초기화
    private static Singleton singleton = new Singleton() {};
    
    // private 접근 권한을 갖는 생성자 선언
    private Singleton() {};

    // public 접근 권한을 가지는 정적 메소드 선언
    public static Singleton getInstance() {
        return singleton;
    } 
}
```

---
**싱글톤 객체가 동일한 객체를 가리키는지 확인하기**

```java
class Main {
  public static void main(String[] args) {
  Singleton obj1 = Singleton.getInstance();
  Singleton obj2 = Singleton.getInstance();

    // 동일한 객체를 참조하는지 확인
    if (obj1 == obj2) {
      System.out.println("같은 Singleton 객체 입니다.");
    } else {
      System.out.println("다른 Singleton 객체 입니다.");
    }
  }
}
// 같은 Singleton 객체 입니다. 
```


## 상속

객체 지향 프로그래밍에서는 부모 역할의 상위 객체와 자식 역할의 하위 객체가 있다. 부모 객체는 자기가 가지고 있는 필드와 메소드를 자식 객체에게 물려주어 자식 객체가 사용할 수 있도록 하는 것을 `상속`이라 한다.

:::tip

상속을 왜 사용할까?

  1. 코드의 재사용성을 높인다.
    
  부모 객체의 필드와 메소드를 자식이 그대로 사용할 수 있어 잘 정의된 코드를 재정의할 필요가 없다.
  
  2. 유지 보수 시간을 최소화시켜 준다.
    
  부모 객체의 필드와 메소드를 수정하면 모든 자식 객체들은 수정된 필드와 메소드를 사용할 수 있다.
:::

## 다형성

다형성이란 사용 방법은 동일하지만 실행 결과가 다양하게 나오는 성질을 의미한다. 컴퓨터는 여러개의 부품의 집합으로 이루어져 있고 부품을 교체했을 때 더 나은 성능을 보여줄 수 있다. 이와 마찬가지로 프로그램을 구성하는 객체를 변경하면 프로그램의 실행 성능이 다르게 나올 수 있다.

- 다형성을 구현하기 위해서는 **자동 타입 변환**과 **재정의 기술**이 필요하다. 
